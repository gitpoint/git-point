So I was looking at the Issue screen, and decided to try and implement comments creation/edition/removal, to challenge the proxy idea.

And boy, oh boy, I think I've found a really cool way to orchestrate everything in store :D 

If you think about it, our interaction with entities from GitHub is always one of following: 

 - list: get a list of entities (events, issue comments, starred repos,..)
 - get: get a single entity (a repo, a user)
 - create: create an entity (comment, a repo, an issue)
 - delete: remove a single entities (a comment, a member from an org)
 - update: update an entity (edit a comment)


I rewrote the Proxy/Client relation in order to match that logic :tada:

Changes are:

 - Methods from the Client now return a call configuration object instead of fetch()ing
 - The proxy who used to react to the fetch(), now perform it itself according to the call configuration

This basically just shift the fetch() call out of the client and into the proxy, in order to
give the proxy more ways to react to the different types of calls.

And since the proxy now have more hindsight about what just happened to the entity, he is able to update
the store & paginations accordingly. 

For example, let's take the "Issue screen", on issue 700 of the gitpoint repo:

We currently fetch a `list` of comments, that we store in the ISSUES_GET_COMMENTS[gitpoint/git-point-700]


This configuration object tells the proxy:
 - what type of operation this is, what kind of response we are expecting, and if the operation deals with an item from a list,

 - The proxy now analyze this configuration object, blocks or performs the fetch() call.





 Client's method 


Up until now, we've been dealing only with "list" and "get" since I introduced the new API.


A "list" call create a pagination in `getState().pagination`, named after the Client method name:
  `client.issues.getComments("gitpoint/git-point", 700)` will end up storing 


When it came to dealing with "create/delete/update"